# Список тем и вопросов для собеседования на web-backend developer
## Работа сети и архитектура приложений
### Чистая архитектура
**Тезисно**  
- Независимость от фреймворка – Архитектура не зависит от существования какой-либо библиотеки. Это позволяет использовать фреймворк в качестве инструмента, вместо того, чтобы втискивать свою систему в рамки его ограничений.
- Тестируемость – Бизнес-правила могут быть протестированы без пользовательского интерфейса, базы данных, веб-сервера или любого другого внешнего компонента.
- Независимоcть от UI – Пользовательский интерфейс можно легко изменить, не изменяя остальную систему. Например, веб-интерфейс может быть заменен на консольный, без изменения бизнес-правил.
- Независимоcть от базы данных – Вы можете поменять Oracle или SQL Server на MongoDB, BigTable, CouchDB или что-то еще. Ваши бизнес-правила не связаны с базой данных.
- Независимость от какого-либо внешнего сервиса – По факту ваши бизнес правила просто ничего не знают о внешнем мире.  

[Более подробно](https://habr.com/ru/post/269589)  

### Верхнеуровневый процесс перехода по ссылке  
*Что происходит, когда вбиваешь в адресной строке **sitename.ru***
- Техническая подоплёка, в которой браузер разбирает, что ему передано – поисковый запрос или адрес
- Проверка, как обращаться к сайту (по какой версии протокола HTTP или HTTPS) 
- Получение по имени IP адреса (если он есть, если его нет – запрос к DNS серверу, где сервер обычно – DNS-сервер провайдера)
- Создание TCP соединения
- Передаются данные пока инициатор прекращения соединения не отправляет пакет FIN и ожидает получить его от второй стороны
- Проверка подписи сертификата 
- Обмен данными с помощью протокола HTTP
- Отдельные ресурсы по типу картинок могут запрашиваться клиентом(браузером) еще несколькими запросами
- Отображение результата пользователю  

[Более подробно](https://habr.com/ru/company/htmlacademy/blog/254825)  

### Протоколы
**UDP**  
- Транспортный протокол, передающий сообщения-дата граммы без необходимости установки соединения в IP-сети
-	Не требует отклика от клиента и допускает потери пакетов при передаче данных  

**TCP**  
-	Транспортный протокол передачи данных в сетях TCP/IP, предварительно устанавливающий соединение с сетью
-	Требует заранее установленного соединения и позволяет контролировать процесс передачи данных  

**Отличия**  
-	TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует.
- TCP нумерует пакеты при передаче, а UDP нет
- TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию и подтверждать получение предыдущего пакета.
-	TCP требует заранее установленного соединения, UDP соединения не требует, у него это просто поток данных.
-	UDP обеспечивает более высокую скорость передачи данных.
-	TCP надежнее и осуществляет контроль над процессом обмена данными.
-	UDP предпочтительнее для программ, воспроизводящих потоковое видео, виде/телефонии, сетевых игр.
-	UPD не содержит функций восстановления данных

### Основные типы HTTP запросов 
[Коротко об HTTP](https://habr.com/ru/post/215117)  
[Разница версий HTTP](https://hostiq.ua/wiki/http-https) 

Главное отличие HTTP (:80) от HTTPS (:443), что второй – надстройка над первым, которая использует защищенный протокол для передачи данных. Защита обеспечивается с помощью SSL сертификата  

- Какие типы бывают и для чего предназначены
  -	OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса
  -	GET - Используется для запроса содержимого указанного ресурса
  -	HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело, используется для извлечения метаданных
  -	POST - Применяется для передачи пользовательских данных заданному ресурсу
  -	PUT - Применяется для загрузки содержимого запроса на указанный в запросе URI
  -	PATCH - Аналогично PUT, но применяется только к фрагменту ресурса
  -	DELETE - Удаляет указанный ресурс
  -	TRACE - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе
  -	CONNECT - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси
- Коды запросов
  -	1хх – Информационный 
  -	2хх – Успешный 
  -	3хх – Перенаправление 
  -	4хх – Ошибка на стороне клиента
  -	5хх – Ошибка на стороне сервера  

### REST API
[Описание на wiki](ru.wikipedia.org/wiki/REST)  
Архитектурный стиль взаимодействия компонентов распределённого приложения в сети  
- Требования
  -	Модель клиент-сервер
  -	Отсутствие состояния – в отсутствие запросов никакая информация о клиенте на стороне сервера не храниться
  -	Кэширование – ответы должны иметь явный признак, нужно ли их кэшировать или нет
  -	Единообразие интерфейса
  -	Слои
  -	Код по требованию (необязательное ограничение)  

### SOAP  
[Описание на wiki](https://ru.wikipedia.org/wiki/SOAP)  
Протокол обмена структурированными сообщениями в распределённой вычислительной среде
- Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC)
- Сейчас протокол используется для обмена произвольными сообщениями в формате XML
-	Использование SOAP для передачи сообщений увеличивает их объём и снижает скорость обработки. В системах, где скорость важна, чаще используется пересылка XML-документов через HTTP напрямую, где параметры запроса передаются как обычные HTTP-параметры.

### Protocol Buffers
[Описание на wiki](https://ru.wikipedia.org/wiki/Protocol_Buffers)  
Протокол сериализации данных, предложенный, как альтернатива устаревшему XML.  
Согласно заданным правилам формируется описание для структур данных, которое позволяет сгенерировать методы сериализации/десириализации объекта в нужном языке программирования.
На текущий момент большая часть всех популярных языков программирования имеет реализованные инструменты для работы с ним

### gRPC
[Описание на wiki](https://ru.wikipedia.org/wiki/GRPC)  
Система удалённого вызова процедур, даже с учётом кроссплатформенности используемых технологий.  
Транспорт - http/2  
Язык описание интерфейсов - protocol buffers  

Типы методов обслуживания:
- Унарный RPC (Unary RPC) — клиент отправляет один запрос на сервер и получает один ответ обратно, как при обычном вызове функции.  
- Серверные потоковые RPC (Server streaming RPC), когда клиент отправляет запрос на сервер и получает поток для чтения последовательности сообщений обратно. Клиент читает из возвращенного потока, пока не кончатся сообщения. gRPC гарантирует упорядочение сообщений в рамках отдельного вызова RPC.  
- Клиентские потоковые RPC (Client streaming RPC), в которых клиент записывает последовательность сообщений и отправляет их на сервер, снова используя предоставленный поток. После того, как клиент закончил писать сообщения, он ждет, пока сервер прочитает их и вернет свой ответ. Опять же, gRPC гарантирует упорядочение сообщений в рамках отдельного вызова RPC.  
- RPC с двунаправленной потоковой передачей (Bidirectional streaming RPC), где обе стороны отправляют последовательность сообщений, используя поток чтения-записи. Два потока работают независимо, поэтому клиенты и серверы могут читать и писать в любом порядке: например, сервер может дождаться получения всех клиентских сообщений, прежде чем записывать свои ответы, или он может поочередно читать сообщение, а затем писать сообщение, или какая-то другая комбинация чтения и записи. Порядок сообщений в каждом потоке сохраняется.

### gRPC
[Статья на habr](https://habr.com/ru/company/intel/blog/165903/)  
[Примеры использования на GOLANG](https://golang.hotexamples.com/ru/examples/github.com.dorzheh.deployer.utils.hwinfo.host/NUMA/-/golang-numa-class-examples.html)
TODO - Добавить описание

## Микросервисная архитектура

### Возможные вопросы по микросервисам
 - [Плюсы и минусы микросервисов](https://habr.com/ru/post/261689/)  
 - Что такое микросервисы и с чем их употребляют [для начинающих](https://habr.com/ru/post/480914/) и [более фундаментально](https://habr.com/ru/post/249183/)  
  
**Какие преимущества ты видишь у микросервисной архитектуры по сравнению с монолитом? А какие недостатки?** 
-	Жесткие границы модулей (+) и Увеличение распределённости (-)
-	Независимый деплоймент (+) и Итоговая консистентность (Согласованность) (-)
-	Технологическое разнообразие (+) и Эксплуатационная сложность (-)

**Что ты использовал (или, о чем слышал) для трассировки сервисов? Для мониторинга? А для логирования?**  
- Трассировка/ Логгирование
  - Elasticsearch
  - Logstash
  - Kibana
  - Graylog
- Мониторинг
  - Как быть с консистентностью данных между несколькими микросервисами? -> Какое-то время хранить инфо о данных для восстановления/блокировки дублей, чтобы избежать потери данных и их задубливания  

## Базы данных
Немного о [разнице SQL и NOSQL решений](https://tproger.ru/translations/sql-nosql-database-models/)  

**Основные примеры**  
- SQL
  - SQLite: очень мощная встраиваемая РСУБД
  - MySQL: самая популярная и часто используемая РСУБД
  - PostgreSQL: самая продвинутая и гибкая РСУБД
  - Oracle: мощная и гибкая СУБД, но с высокой стоимостью лицензии
- NOSQL
  - MongoDB – хранит данные в формате, похожем на JSON(Документ)
  - ClickHouse – напоминает классические реляционки, колоночная СУБД
  - Aerospike – хранит данные в формате «Ключ-значение»  
  
**Основные отличия**  
1. Структура и тип хранящихся данных – SQL/реляционные базы данных требуют наличия однозначно определённой структуры хранения данных, а NoSQL базы данных таких ограничений не ставят
2. Запросы – вне зависимости от лицензии, РСУБД реализуют SQL-стандарты, поэтому из них можно получать данные при помощи языка SQL. Каждая NoSQL база данных реализует свой способ работы с данными
3. Масштабируемость – оба решения легко растягиваются вертикально (например, путём увеличения системных ресурсов). Тем не менее, из-за своей современности, решения NoSQL обычно предоставляют более простые способы горизонтального масштабирования (например, создания кластера из нескольких машин)
4. Надёжность – когда речь заходит о надёжности, SQL базы данных однозначно впереди
5. Поддержка – РСУБД имеют очень долгую историю. Они очень популярны, и поэтому получить поддержку, платную или нет, очень легко. Поэтому, при необходимости, решить проблемы с ними гораздо проще, чем с NoSQL, особенно если проблема сложна по своей природе (например, при работе с MongoDB)
6. Хранение и доступ к сложным структурам данных – по своей природе реляционные базы данных предполагают работу с сложными ситуациями, поэтому и здесь они превосходят NoSQL-решения

**Индексы**  
[Обзор](https://habr.com/ru/post/102785) типов индексов в разных РСУБД  

- Сравнение основных типов
  - B – деревья
    - Хороши для данных с высокой кардинальностью
    - Хороши для баз данных [OLTP](https://ru.wikipedia.org/wiki/OLTP)
    - Занимают много места
    - Легко обновляются
  - Битовые индексы
    - Хороши для данных с низкой кардинальностью
    - Хороши для приложений хранилищ данных [OLAP](https://ru.wikipedia.org/wiki/OLAP)
    - Небольшие по размеру
    - Долгий процесс обновления
  - HASH индексы
    - Сравнивается не значение, а его хэш
    - Нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null»
    - Не уникален, для совпадающих хэшей применяются методы разрешения коллизий

**Термины** - TODO - Изменить название на более логичное  

- [Транзакция](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) - группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными
- [Кардинальность](https://ru.m.wikipedia.org/wiki/%D0%9C%D0%BE%D1%89%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0) - уникальность данных. Высокая кардинальность - уникальные данные, низкая кардинальность - повторяющиеся данные
- [ACID](https://ru.wikipedia.org/wiki/ACID) - требования к информационной системе
  - [Atomicity](https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C) — Атомарность, гарантирует, что никакая транзакция не будет зафиксирована в системе частично
  - [Consistency](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) — Согласованность. Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных
  - Isolation — Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат
  - Durability — Стойкость. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу
- [CAP](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP) - утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств

## Инфраструктура и деплой
### Общая информация
-	Что такое сине-зеленый деплой([blue-green deployment](https://habr.com/ru/post/309832/))?
-	Как можно разворачивать приложения? Какие плюсы и минусы бывают у разных подходов
-	Для чего нужны системы оркестрации контейнеров? -> Для управления сложными системами, каждый компонент которых это контейнер и выключение одного компонента не выключает всю систему, так же, как и его замена
-	Docker
-	Kubernetes
-	CI\CD
### Окружение
- UNIX
  - Общий опыт использования 
    - GREP – Поиск
    - TAIL – Логи
    - MC – Упрощенный интерфейс интерфейса
    - GITK - Утилита для просмотра ветвления репозитория 
    - HTOP - Монитор ресурсов
    - SSH - Работа с шифрованием

## GIT
- add - Добавление изменений в индекс 
- commit - Сбор всех проиндексированных файлов в слепок и сохранение его в локальную версию репозитория
- status - Отображение всех изменений, совершенных с файлами в ветке
- push - Отправка изменений в удалённый репозиторий, связанный с локальным
- rebase - Позволяет переместить все коммиты, совершенные с момента создания ветки, после последнего коммита из выбранной ветки
- cherry-pick - Позволяет поместить выбранные коммиты, после последнего из выбранной ветки
- checkout - Переключение между ветками и откат файлов к состоянию последнего коммита в удалённой версии ветки
- branch - Работа с локальными и удалёнными ветками

## Алгоритмы
**Виды**  
-	[Черно-красное дерево](https://habr.com/ru/post/330644)
-	[Бинарное дерево](https://habr.com/ru/post/267855)
-	[Сортировка](https://tproger.ru/translations/sorting-for-beginners)

# Справочная информация по Golang
## [Вопросы](https://github.com/NineStems/junior-backend-developer-topics-and-questions/blob/main/langs-questions/golang.md) 
## [Справочные материалы](https://github.com/NineStems/junior-backend-developer-topics-and-questions/blob/main/lib/golang.md)  

# Задачи для разминки 
## Задачки на БД
**№1**  
Составить структуру таблиц и связей (спроектировать бд библиотеки, автор, книга, пользователь. Много авторов, книга на руках у одного пользователя)

**№2**  
Несколько выборок с группировками по этой созданной БД
-	Найдите книги (в т.ч названия), которые на руках у пользователя и написанные более чем 2 авторами
-	Топ 3 популярных авторов  

**№3**  
Пояснить какой индекс будет создан и почему именно такой при использовании конкретного запроса  
Построить оптимальный индекс для `SELECT * FROM employee WHERE sex = 'm' AND salary > 300000 AND age = 20 ORDER BY created_at`  

## Задачи на алгоритмы TODO 
Доп задачки для переноса - [тут](https://habr.com/ru/company/rebrainme/blog/540354/)
Еще задачки - [тут](https://tproger.ru/problems/sobesedovanie-na-poziciju-middle-javascript-razrabotchika-primery-zadach-i-neobhodimye-znanija/)  

**№1**  
Написать функцию, которая возвращает массив заданной длины, с уникальными числами  

**№2**  
Написать функцию, которая будет валидировать строку со скобочками (задачка на скобочки. Нужно определить валидно ли расставлены скобочки {}{[]}() – true , {)(} – false, (([(]))) – false)  

**№3**  
Написать функцию, которая принимает число n и возвращает матрицу nxn, где заполняет её значениями спирально (справа налево, к центру)  

**№4**  
Есть структура геолокаций Страна-Регион-Город. На вход подаётся два массива, которые могут содержать произвольное количество элементов(но не более 3х) или быть пустыми.  
Первый элемент, это то, что должно быть в итоге показано, а второй - то, что должно быть исключено из показа.
Нужно определить пересекаются ли элементы и вернуть те, что пересекаются, например:  
- Россия-Краснодарский край-Краснодар и Россия-Краснодарский край = Пересекаются и нужно исключить весь Краснодарский край
- Россия-Краснодарский край и Россия-Краснодарский край-Краснодар = Пересекаются и нужно исключить только Краснодар
- Россия-Ростовская область и Россия-Краснодарский край-Краснодар = Не пересекаются и исключать ничего не нужно

## Задачи на понимание архитектуры
**№1**  
Есть два сервиса, сервис один сохраняет данные и отправляет их в медленный сервис два - как бы вы организовали работу двух этих сервисов с учётом того, что сервис два медленный и только получает данные  

# Материалы, использованные при подготовке данного документа
- https://medium.com/@victor_nerd/golang-interview-questions-bd3064f2ff69
- https://habr.com/ru/company/oleg-bunin/blog/521582/
- https://www.coursera.org/learn/golang-webservices-1/home/welcome
